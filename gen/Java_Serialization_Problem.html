<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
<head>
   <meta http-equiv="content-type" content="text/html; charset=utf-8" />
   <meta name="author" content="Mars Gu" />
   <link href="http://kevinburke.bitbucket.org/markdowncss/markdown.css" rel="stylesheet"></link>
</head>
<body>
<h1 id="java-serialization-problem">Java Serialization Problem</h1>
<h3>问题</h3>
<p>今天在序列化一个Scala的函数的时候，碰到一个java序列化的问题，程序如下：</p>
<pre><code>import java.io.{FileOutputStream, ObjectOutputStream}
import org.apache.spark.rdd.RDD

object Test {
  def main(args: Array[String]): Unit ={
    val obj: RDD[Int] =&gt; Int = rdd =&gt; rdd.first()
    val oout = new ObjectOutputStream(new FileOutputStream(&quot;/tmp/obj&quot;))
    oout.writeObject(obj)
  }
}</code></pre>
<p>Maven配置中，spark-core设为provided，因为在运行时上述程序是不需要加载RDD的类。</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.apache.spark&lt;/groupId&gt;
    &lt;artifactId&gt;spark-core_2.10&lt;/artifactId&gt;
    &lt;version&gt;${spark.version}&lt;/version&gt;
    &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;</code></pre>
<p>结果运行时出现了如下的错误：</p>
<pre><code>Exception in thread &quot;main&quot; java.lang.NoClassDefFoundError: org/apache/spark/rdd/RDD
    at java.lang.Class.getDeclaredMethods0(Native Method)
    at java.lang.Class.privateGetDeclaredMethods(Class.java:2570)
    at java.lang.Class.getDeclaredMethod(Class.java:2002)
    at java.io.ObjectStreamClass.getPrivateMethod(ObjectStreamClass.java:1431)
    at java.io.ObjectStreamClass.access$1700(ObjectStreamClass.java:72)
    at java.io.ObjectStreamClass$2.run(ObjectStreamClass.java:494)
    at java.io.ObjectStreamClass$2.run(ObjectStreamClass.java:468)
    at java.security.AccessController.doPrivileged(Native Method)
    at java.io.ObjectStreamClass.&lt;init&gt;(ObjectStreamClass.java:468)
    at java.io.ObjectStreamClass.lookup(ObjectStreamClass.java:365)
    at java.io.ObjectOutputStream.writeObject0(ObjectOutputStream.java:1133)
    at java.io.ObjectOutputStream.writeObject(ObjectOutputStream.java:347)
    at com.iqiyi.jupiter.Test$.main(Test.scala:20)
    at com.iqiyi.jupiter.Test.main(Test.scala)
    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)
    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
    at java.lang.reflect.Method.invoke(Method.java:606)
    at com.intellij.rt.execution.application.AppMain.main(AppMain.java:140)
Caused by: java.lang.ClassNotFoundException: org.apache.spark.rdd.RDD
    at java.net.URLClassLoader$1.run(URLClassLoader.java:366)
    at java.net.URLClassLoader$1.run(URLClassLoader.java:355)
    at java.security.AccessController.doPrivileged(Native Method)
    at java.net.URLClassLoader.findClass(URLClassLoader.java:354)
    at java.lang.ClassLoader.loadClass(ClassLoader.java:425)
    at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:308)
    at java.lang.ClassLoader.loadClass(ClassLoader.java:358)
    ... 19 more</code></pre>
<h3>分析</h3>
<p>Scala的函数<code>val obj: RDD[Int] =&gt; Int = rdd =&gt; 1</code>会被翻译为Function类</p>
<pre><code>val obj1 = new Function1[RDD[Int], Int]() {
  override def apply(v1: RDD[Int]): Int = {
    1
  }
}</code></pre>
<p>根据错误的stack信息，可以推测出Java在序列化Functoin1这个类的时候加载了RDD的类。原因如下：</p>
<ol>
<li><p>如果用户在类里面定义了writeObject方法，Java会优先选择这个方法来序列化该类。</p></li>
<li><p>所以Java会首先通过反射的机制检查类中有没有writeObject方法<br />```<br />ObjectStreamClass.java</p></li>
</ol>
<p>getPrivateMethod(cl, &quot;writeObject&quot;,<br /> new Class&lt;?&gt;[] { ObjectOutputStream.class },<br /> Void.TYPE);</p>
<pre><code>
3. 在检查有没有writeObject方法的时候，调用了getDeclaredMethod获取所以的方法</code></pre>
<p>private static Method getPrivateMethod(Class&lt;?&gt; cl, String name,<br /> Class&lt;?&gt;[] argTypes,<br /> Class&lt;?&gt; returnType)<br /> {<br /> try {<br /> Method meth = cl.getDeclaredMethod(name, argTypes);<br /> meth.setAccessible(true);<br /> int mods = meth.getModifiers();<br /> return ((meth.getReturnType() == returnType) &amp;&amp;<br /> ((mods &amp; Modifier.STATIC) == 0) &amp;&amp;<br /> ((mods &amp; Modifier.PRIVATE) != 0)) ? meth : null;<br /> } catch (NoSuchMethodException ex) {<br /> return null;<br /> }<br /> }</p>
<pre><code>
4. getDeclaredMethod中调用了privateGetDeclaredMethods</code></pre>
<p>public Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes)<br /> throws NoSuchMethodException, SecurityException {<br /> // be very careful not to change the stack depth of this<br /> // checkMemberAccess call for security reasons<br /> // see java.lang.SecurityManager.checkMemberAccess<br /> checkMemberAccess(Member.DECLARED, Reflection.getCallerClass(), true);<br /> Method method = searchMethods(privateGetDeclaredMethods(false), name, parameterTypes);<br /> if (method == null) {<br /> throw new NoSuchMethodException(getName() + &quot;.&quot; + name + argumentTypesToString(parameterTypes));<br /> }<br /> return method;<br /> }</p>
<pre><code>
5.privateGetDeclaredMethods中调用了getDeclaredMethods0，该方法是一个native方法，
getDeclaredMethods0会寻找所有方法中涉及到的类的定义，所以会出现RDD类找不到的错误。</code></pre>
<p>private Method[] privateGetDeclaredMethods(boolean publicOnly) {<br /> checkInitted();<br /> Method[] res = null;<br /> if (useCaches) {<br /> clearCachesOnClassRedefinition();<br /> if (publicOnly) {<br /> if (declaredPublicMethods != null) {<br /> res = declaredPublicMethods.get();<br /> }<br /> } else {<br /> if (declaredMethods != null) {<br /> res = declaredMethods.get();<br /> }<br /> }<br /> if (res != null) return res;<br /> }<br /> // No cached value available; request value from VM<br /> res = Reflection.filterMethods(this, getDeclaredMethods0(publicOnly));<br /> if (useCaches) {<br /> if (publicOnly) {<br /> declaredPublicMethods = new SoftReference&lt;&gt;(res);<br /> } else {<br /> declaredMethods = new SoftReference&lt;&gt;(res);<br /> }<br /> }<br /> return res;<br /> }</p>
<pre><code>
### 解决
因为所以出现在Function1方法中的类型都需要存在在运行时环境中，所以我们可以定义一个Wrapper类来包装RDD。
</code></pre>
<p>import java.io.{FileOutputStream, ObjectOutputStream}<br />import org.apache.spark.rdd.RDD</p>
<p>class Wrapper<a href="@transient%20val%20value:%20T">T</a></p>
<p>object Test {<br /> def main(args: Array[String]): Unit ={<br /> val obj: Wrapper[RDD[Int]] =&gt; Int = rdd =&gt; rdd.value.first()<br /> val oout = new ObjectOutputStream(new FileOutputStream(&quot;/tmp/obj&quot;))<br /> oout.writeObject(obj)<br /> }<br />}<br />```</p>
<h3>思考</h3>
<p>个人觉得这个可以算一个Java的bug，getPrivateMethod方法只捕获了NoSuchMethodException，其实应该再捕获一个NoClassDefFoundError。</p>

</body>
</html>
