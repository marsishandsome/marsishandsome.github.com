<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
<head>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <meta name="author" content="Mars Gu" />

    <title>Mars的笔记</title>

    <!--post-->
    <link href="http://marsishandsome.github.io/template/post.css" rel="stylesheet"></link>

    <script>
        (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
        (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
        m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
        })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

        ga('create', 'UA-72149435-1', 'auto');
        ga('send', 'pageview');
    </script>
</head>
<body>
<h1 id="paxos">Paxos</h1>
<h2>参考</h2>
<ul>
<li><a href="http://research.microsoft.com/en-us/um/people/lamport/pubs/lamport-paxos.pdf">Paxos论文</a></li>
<li><a href="http://research.microsoft.com/en-us/um/people/lamport/pubs/paxos-simple.pdf">Paxos Made Simple</a></li>
<li><a href="http://www.tudou.com/programs/view/e8zM8dAL6hM/">Paxos和分布式系统 知行学社</a></li>
</ul>
<h2 id="paxos">Paxos要解决的问题</h2>
<p>Paxos用来确定一个不可变量的取值，一旦确定将不再更改（不可变性），并且可以获取到（可读取性）。</p>
<ul>
<li>一个分布式存储系统，可以存储名为var的变量</li>
<li>系统内部由多个Acceptor组成，负责存储和管理var</li>
<li>外部由多个Proposer机器任意并发调用API，向系统提交不同的var取值</li>
<li><p>系统对外API：propose(var, V) =&gt; <ok, f> or <error></p></li>
<li>系统需要保证var取值满足一致性</li>
<li>如果var的取值没有确定，则var的取值为null</li>
<li><p>一旦var的取值被确定，则不可更改，并且可以一直获取到这个值</p></li>
<li>系统需要满足容错特性</li>
<li>可以容忍任意Proposer机器故障</li>
<li><p>可以容忍半数以下Acceptor机器故障</p></li>
</ul>
<h2>四个难点</h2>
<ol>
<li>Proposer并发管理</li>
<li>保证var变量的不可变性</li>
<li>容忍任意Proposer机器故障</li>
<li>容忍半数以下Acceptor机器故障</li>
</ol>
<h2>方案一</h2>
<p>思路： 使用单个Acceptor，通过类似互斥锁机制管理并发Proposer</p>
<p>解决： 1. Proposer并发 2. 保证var变量的不可变性</p>
<ul>
<li>Proposer首先想Acceptor申请互斥访问权，申请到了才能申请Acceptor接受自己的值</li>
<li>Acceptor向Proposer发放互斥访问权，谁申请到了就接受谁的值</li>
<li>一旦Acceptor接受了某个Proposer的取值，则认为var的取值被确定，其他Proposer不能再更改</li>
</ul>
<p>Acceptor实现</p>
<pre><code>var accepted_value = null
val lock = new Lock()

def prepare(): (Boolean, Object) = {
  (lock.tryLock(), acepted_value)
}

def release(): Unit = {
  lock.release()
}

def accept(value: Object): Object = {
  if(accepted_value == null) {
    accepted_value = value
  }
  release()
  accepted_value
}</code></pre>
<p>Proposer实现</p>
<pre><code>def propose(value: Object): Object = {
  val (res, accepted_value) = prepare()
  if(accepted_value != null) {
    release()
    accepted_value
  } else {
    if(!res) {
      Thread.sleep(1000)
      propose(value)
    } else {
      accept(value)
    }
  }
}</code></pre>
<h2>方案二</h2>
<p>问题： 获得锁的Acceptor机器故障会导致死锁</p>
<p>思路： 引入抢占式访问权</p>
<p>解决： 3. 容忍任意Propose机器故障</p>
<ul>
<li>引入抢占式访问权</li>
<li>Acceptor可以让某个Proposer获得的访问权失效</li>
<li>之后可以把访问权发放给其他Proposer</li>
<li>Proposer向Acceptor申请访问权时指定编号epoch，获得访问权后才能向Acceptor提交取值</li>
<li>Acceptor采用喜新厌旧原则</li>
<li>一旦收到更大的epoch申请，马上让旧的epoch失效，不再接受旧的epoch的取值</li>
<li>然后给新的epoch发放访问权，只接收新的epoch的取值</li>
<li>为了保持一致性</li>
<li>在旧的epoch无法生成确定性取值时，新的epoch才会提交取值，不会冲突</li>
<li>一旦epoch形成确定性取值，新的epoch肯定可以获得该取值，并认同该取值</li>
</ul>
<p>Acceptor实现</p>
<pre><code>var last_prepare_epoch: Integer = null
var accepted_epoch: Integer = null
var accepted_value: Object = null
val lock = new Lock()

def prepare(epoch: Integer): (Boolean, Integer, Object) = {
  lock.lock()
  var res = false
  if(last_prepare_epoch == null || epoch &gt; last_prepare_epoch) {
    last_prepare_epoch = epoch
    res = true
  }
  lock.release()
  (res, accepted_epoch, accepted_value)
}

def accept(epoch: Integer, value: Object): (Boolean, Integer, Object) = {
  lock.lock()
  var res = false
  if(epoch == last_prepare_epoch &amp;&amp; accepted_value == null) {
    accepted_value = value
    accepted_epoch = epoch
    res = true
  }
  lock.release()
  (res, accepted_epoch, accepted_value)
}</code></pre>
<p>Proposer实现</p>
<pre><code>def propose(value: Object): Object {
  doPropose(value, 1)
}

private def doPropose(value: Object, epoch: Integer): Object = {
  val (res, accepted_epoch, accepted_value) = prepare(epoch, value))
  if(accepted_value != null) {
    accepted_value
  } else {
    if(!res) {
      Thread.sleep(1000)
      propose(value, accepted_epoch + 1)
    } else {
      doAccept(value, epoch)
    }
}

private def doAccept(value: Object, epoch: Integer): Object = {
  val (res, accepted_epoch, accepted_value) = accept(epoch, value)
  if(accepted_value != null) {
    accepted_value
  } else {
    Thread.sleep(1000)
    doPropose(value, accepted_epoch + 1)
  }
}</code></pre>
<h2>方案三</h2>
<p>问题： Acceptor机器单点</p>
<p>思路： 引入多个Acceptor</p>
<p>解决： 4. 容忍半数以下Acceptor机器故障</p>
<ul>
<li>少数服从多数原则</li>
<li>某个epoch的取值f被半数以上Acceptor接受，则次var值被确定为f</li>
<li>Propose</li>
<li>第一阶段：选定epoch，获得半数以上Acceptor的访问权和对应的一组var取值</li>
<li>第二阶段：
<ul>
<li>如果var取值为空，则旧的epoch无法取得确定性取值，努力使<epoch, V>成为确定性取值</li>
<li>如果var取值存在，认同最大accepted_epoch对应的取值f，努力使<epoch, f>成为确定性取值</li>
</ul></li>
</ul>
<p>Acceptor实现</p>
<pre><code>同方案二</code></pre>
<p>Proposer实现</p>
<pre><code>def acceptors: List[Acceptor]
def numOfAcceptors: Integer = acceptors.size

def propose(value: Object): Object {
  doPropose(value, 1)
}

private def doPropose(value: Object, epoch: Integer): Object = {
  val prepareResults = acceptors.map(_.prepare(epoch, value)).filter(返回结果的acceptor)

  if(prepareResults.size * 2 &gt; numOfAcceptors) {
    if(prepareResults.exists(_._3 != null) {
      val (_, maxEpoch, maybeValue) = prepareResults.filter(_._3 != null).sort(_._2)
      val numOfMaxEpochValue = prepareResults.filter(_._3 == maybeValue)
      if(numOfMaxEpochValue * 2 &gt;= numOfAcceptors) {
        doAccept(maybeValue, epoch)
      } else {
        Thread(1000)
        doPropose(maxEpochValue, epoch + 1)
      }
    } else {
        doAccept(value, epoch)
    }
  } else {
    Thread.sleep(1000)
    doPropose(value, epoch + 1)
  }
}

private def doAccept(value: Object, epoch: Integer): Object = {
  val acceptResults = acceptors.map(_.accept(value, epoch)).filter(返回结果的acceptor)

  if(acceptResults.size * 2 &gt; numOfAcceptors) {
    val (_, maxEpoch, maybeValue) = acceptResults.filter(_._3 != null).sort(_._2)
    val numOfMaxEpochValue = acceptResults.filter(_._3 == maybeValue)
    if(numOfMaxEpochValue * 2 &gt;= numOfAcceptors) {
      maybeValue
    } else {
      Thread.sleep(1000)
      doPropose(value, epoch + 1)
    }
  } else {
    Thread.sleep(1000)
    doPropose(value, epoch + 1)
  }
}</code></pre>
<h2 id="paxos">Paxos的应用</h2>
<ul>
<li>多副本更新操作序列</li>
<li>Chubby</li>
<li>Megastore</li>
<li>Spanner</li>
<li>Zookeeper</li>
</ul>
</body>
</html>
