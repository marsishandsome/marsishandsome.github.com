<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
<head>
   <meta http-equiv="content-type" content="text/html; charset=utf-8" />
   <meta name="author" content="Mars Gu" />
   <link href="http://kevinburke.bitbucket.org/markdowncss/markdown.css" rel="stylesheet"></link>
</head>
<body>
<h1>Principles of Reactive Programming</h1>
<ul>
<li>by Martin Odersky, Erik Meijer, Roland Kuhn</li>
<li><a href="https://class.coursera.org/reactive-002/auth">Coursera Link</a></li>
</ul>
<h1>Week 1</h1>
<h3>Collections</h3>
<p>Translation of For:
1. map
<code>for (x &lt;- e1) yield e2
==&gt;
e1.map(x =&gt; e2)</code>
2. withFilter
<code>for (x &lt;- e1 if f; s) yield e2
==&gt;
for (x &lt;- e1.withFilter(x =&gt; f); s) yield e2</code>
3. flatMap
<code>for (x &lt;- e1; y &lt;- e2; s) yield e3
==&gt;
e1.flatMap(x =&gt; for(y &lt;- e2; s) yield e3)</code></p>
<h3>Functional Random Generators</h3>
<p>Generator
```
trait Generator[+T] {
  def generate: T
}</p>
<p>val integers = new Generator[Int] {
  val rand = new java.util.Random
  def generate = rand.nextInt()
}</p>
<p>val booleans = new Generator[Boolean] {
  def generate = integers.generate &gt; 0
}</p>
<p>val pairs = new Generator[(Int, Int)] {
  def generate = (integers.generate, integers.generate)
}
```</p>
<p>Streamlining
<code>val booleans = for (x &lt;- integers) yield x &gt; 0
def pairs[T, U](t: Generator[T], u: Generator[U]) = for {
  x &lt;- t
  y &lt;- u
} yield (x, y)</code></p>
<p>Generator with map and flatMap
<code>trait Generator[+T] {
  self =&gt;
  def generate: T
  def map[S](f: T =&gt; S): Generator[S] = new Generator[S] {
    def generate = f(self.generate)
  }
  def flatMap[S](f: T =&gt; Generator[S]): Generator[S] = new Generator[S] {
    def generate = f(self.generate).generate
  }
}</code></p>
<h3>Monads</h3>
<p>Monads定义:
<code>trait M[T] {
def flatMap[U](f: T =&gt; M[U]): M[U]
}
def unit[T](x: T): M[T]</code></p>
<p>map定义:
<code>m map f == m flatMap (x =&gt; unit(f(x)))
== m flatMap (f andThen unit)</code></p>
<p>Monads三大定律:
1. 结合律
<code>m flatMap f flatMap g == m flatMap (x =&gt; f(x) flatMap g)</code>
2. Left Unit
<code>unit(x) flatMap f == f(x)</code>
3. Right Unit
<code>m flatMap unit == m</code></p>
<h1>Week 2</h1>
<h3>Functions and State</h3>
<h3>Identity and Change</h3>
<h3>Loops</h3>
<h3>Imperative Event Handling: The Observer Pattern</h3>
<h3>Functional Reactive Programming</h3>
<h3>A Simple FRP Implementation</h3>
<h1>Week 3</h1>
<h3>Monads and Effects</h3>
<p>Try
<code>abstract class Try[T] {
  def flatMap[S](f: T=&gt;Try[S]): Try[S]
  def flatten[U &lt;: Try[T]]: Try[U]
  def map[S](f: T=&gt;S): Try[T]
  def filter(p: T=&gt;Boolean): Try[T]
  def recoverWith(f: PartialFunction[Throwable,Try[T]]): Try[T]
}
case class Success[T](elem: T) extends Try[T]
case class Failure(t: Throwable) extends Try[Nothing]</code></p>
<p>Adventure
<code>trait Adventure {
  def collectCoins(): Try[List[Coin]]
  def buyTreasure(coins: List[Coin]): Try[Treasure]
}</code></p>
<p>Dealing with failure explicitly
<code>val adventure = Adventure()
val coins: Try[List[Coin]] = adventure.collectCoins()
val treasure: Try[Treasure] = coins match {
  case Success(cs) =&gt; adventure.buyTreasure(cs)
  case failure@Failure(e) =&gt; failure
}</code></p>
<p>Noise reduction: Flatmap
<code>val adventure = Adventure()
val treasure: Try[Treasure] =
  adventure.collectCoins().flatMap { coins =&gt;
  adventure.buyTreasure(coins)
}</code></p>
<p>Using comprehension syntax
<code>val adventure = Adventure()
val treasure: Try[Treasure] = for {
  coins &lt;- adventure.collectCoins()
  treasure &lt;- buyTreasure(coins)
} yield treasure</code></p>
<h3>Latency as an Effect</h3>
<p>Future
```
import scala.concurrent._
import scala.concurrent.ExecutionContext.Implicits.global
trait Future[T] {
def onComplete(callback: Try[T] ⇒ Unit)
    (implicit executor: ExecutionContext): Unit
}</p>
<p>object Future {
  def apply(body: =&gt;T)
      (implicit context: ExecutionContext): Future[T]
}
```</p>
<h3>Combinator on Futures</h3>
<p>Future
<code>trait Awaitable[T] extends AnyRef {
  abstract def ready(atMost: Duration): Unit
  abstract def result(atMost: Duration): T
}
trait Future[T] extends Awaitable[T] {
  def filter(p: T=&gt;Boolean): Future[T]
  def flatMap[S](f: T=&gt;Future[S]): Future[U]
  def map[S](f: T=&gt;S): Future[S]
  def recoverWith(f: PartialFunction[Throwable, Future[T]]): Future[T]
}
object Future {
  def apply[T](body : =&gt;T): Future[T]
}</code></p>
<h3>Composing Futures</h3>
<p>Comprehension
<code>val socket = Socket()
val confirmation: Future[Array[Byte]] = for{
  packet &lt;- socket.readFromMemory()
  confirmation &lt;- socket.sendToSafe(packet)
} yield confirmation</code></p>
<p>Retry
<code>def retry(noTimes: Int)(block: ⇒Future[T]): Future[T] = {
  if (noTimes == 0) {
    Future.failed(new Exception(“Sorry”))
  } else {
    block fallbackTo {
      retry(noTimes–1){ block }
    }
  }
}</code></p>
<p>foldRight &amp; folderLeft
<code>List(a,b,c).foldRight(e)(f) = f(a, f(b, f(c, e)))
List(a,b,c).foldLeft(e)(f)  = f(f(f(e, a), b), c)</code></p>
<p>Retrying to send using foldLeft
<code>def retry(noTimes: Int)(block: =&gt;Future[T]): Future[T] = {
  val ns = (1 to noTimes).toList
  val attempts = ns.map(_ =&gt; ()=&gt;block)
  val failed = Future.failed(new Exception(“boom”))
  val result = attempts.foldLeft(failed)
  ((a,block) =&gt; a recoverWith { block() })
  result
}</code></p>
<p>Retrying to send using foldRight
<code>def retry(noTimes: Int)(block: =&gt;Future[T])= {
  val ns = (1 to noTimes).toList
  val attempts: = ns.map(_ =&gt; () =&gt; block)
  val failed = Future.failed(new Exception)
  val result = attempts.foldRight(() =&gt;failed)
  ((block, a) =&gt; () =&gt; { block() fallbackTo { a() } })
  result ()
}</code></p>
<h3>Async Await</h3>
<h3>Promise, promises</h3>
<h1>Week 4</h1>
<h1>Week 5</h1>
</body>
</html>
