<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">
<head>
   <meta http-equiv="content-type" content="text/html; charset=utf-8" />
   <meta name="author" content="Mars Gu" />
   <link href="http://kevinburke.bitbucket.org/markdowncss/markdown.css" rel="stylesheet"></link>
</head>
<body>
<h1>Principles of Reactive Programming</h1>
<ul>
<li>by Martin Odersky, Erik Meijer, Roland Kuhn</li>
<li><a href="https://class.coursera.org/reactive-002/auth">Coursera Link</a></li>
</ul>
<h1>Week 1</h1>
<h3>Collections</h3>
<p>Translation of For:
1. map
<code>for (x &lt;- e1) yield e2
==&gt;
e1.map(x =&gt; e2)</code>
2. withFilter
<code>for (x &lt;- e1 if f; s) yield e2
==&gt;
for (x &lt;- e1.withFilter(x =&gt; f); s) yield e2</code>
3. flatMap
<code>for (x &lt;- e1; y &lt;- e2; s) yield e3
==&gt;
e1.flatMap(x =&gt; for(y &lt;- e2; s) yield e3)</code></p>
<h3>Functional Random Generators</h3>
<p>Generator
```
trait Generator[+T] {
  def generate: T
}</p>
<p>val integers = new Generator[Int] {
  val rand = new java.util.Random
  def generate = rand.nextInt()
}</p>
<p>val booleans = new Generator[Boolean] {
  def generate = integers.generate &gt; 0
}</p>
<p>val pairs = new Generator[(Int, Int)] {
  def generate = (integers.generate, integers.generate)
}
```</p>
<p>Streamlining
<code>val booleans = for (x &lt;- integers) yield x &gt; 0
def pairs[T, U](t: Generator[T], u: Generator[U]) = for {
  x &lt;- t
  y &lt;- u
} yield (x, y)</code></p>
<p>Generator with map and flatMap
<code>trait Generator[+T] {
  self =&gt;
  def generate: T
  def map[S](f: T =&gt; S): Generator[S] = new Generator[S] {
    def generate = f(self.generate)
  }
  def flatMap[S](f: T =&gt; Generator[S]): Generator[S] = new Generator[S] {
    def generate = f(self.generate).generate
  }
}</code></p>
<h3>Monads</h3>
<p>Monads定义:
<code>trait M[T] {
def flatMap[U](f: T =&gt; M[U]): M[U]
}
def unit[T](x: T): M[T]</code></p>
<p>map定义:
<code>m map f == m flatMap (x =&gt; unit(f(x)))
== m flatMap (f andThen unit)</code></p>
<p>Monads三大定律:
1. 结合律
<code>m flatMap f flatMap g == m flatMap (x =&gt; f(x) flatMap g)</code>
2. Left Unit
<code>unit(x) flatMap f == f(x)</code>
3. Right Unit
<code>m flatMap unit == m</code></p>
<h1>Week 2</h1>
<h3>Imperative Event Handling: The Observer Pattern</h3>
<p>TODO</p>
<h3>Functional Reactive Programming</h3>
<p>TODO</p>
<h3>A Simple FRP Implementation</h3>
<p>TODO</p>
<h1>Week 3</h1>
<h3>Monads and Effects</h3>
<p>Try
<code>abstract class Try[T] {
  def flatMap[S](f: T=&gt;Try[S]): Try[S]
  def flatten[U &lt;: Try[T]]: Try[U]
  def map[S](f: T=&gt;S): Try[T]
  def filter(p: T=&gt;Boolean): Try[T]
  def recoverWith(f: PartialFunction[Throwable,Try[T]]): Try[T]
}
case class Success[T](elem: T) extends Try[T]
case class Failure(t: Throwable) extends Try[Nothing]</code></p>
<p>Adventure
<code>trait Adventure {
  def collectCoins(): Try[List[Coin]]
  def buyTreasure(coins: List[Coin]): Try[Treasure]
}</code></p>
<p>Dealing with failure explicitly
<code>val adventure = Adventure()
val coins: Try[List[Coin]] = adventure.collectCoins()
val treasure: Try[Treasure] = coins match {
  case Success(cs) =&gt; adventure.buyTreasure(cs)
  case failure@Failure(e) =&gt; failure
}</code></p>
<p>Noise reduction: Flatmap
<code>val adventure = Adventure()
val treasure: Try[Treasure] =
  adventure.collectCoins().flatMap { coins =&gt;
  adventure.buyTreasure(coins)
}</code></p>
<p>Using comprehension syntax
<code>val adventure = Adventure()
val treasure: Try[Treasure] = for {
  coins &lt;- adventure.collectCoins()
  treasure &lt;- buyTreasure(coins)
} yield treasure</code></p>
<h3>Latency as an Effect</h3>
<p>Future
```
import scala.concurrent._
import scala.concurrent.ExecutionContext.Implicits.global
trait Future[T] {
def onComplete(callback: Try[T] ⇒ Unit)
    (implicit executor: ExecutionContext): Unit
}</p>
<p>object Future {
  def apply(body: =&gt;T)
      (implicit context: ExecutionContext): Future[T]
}
```</p>
<h3>Combinator on Futures</h3>
<p>Future
<code>trait Awaitable[T] extends AnyRef {
  abstract def ready(atMost: Duration): Unit
  abstract def result(atMost: Duration): T
}
trait Future[T] extends Awaitable[T] {
  def filter(p: T=&gt;Boolean): Future[T]
  def flatMap[S](f: T=&gt;Future[S]): Future[U]
  def map[S](f: T=&gt;S): Future[S]
  def recoverWith(f: PartialFunction[Throwable, Future[T]]): Future[T]
}
object Future {
  def apply[T](body : =&gt;T): Future[T]
}</code></p>
<h3>Composing Futures</h3>
<p>Comprehension
<code>val socket = Socket()
val confirmation: Future[Array[Byte]] = for{
  packet &lt;- socket.readFromMemory()
  confirmation &lt;- socket.sendToSafe(packet)
} yield confirmation</code></p>
<p>Retry
<code>def retry(noTimes: Int)(block: ⇒Future[T]): Future[T] = {
  if (noTimes == 0) {
    Future.failed(new Exception(“Sorry”))
  } else {
    block fallbackTo {
      retry(noTimes–1){ block }
    }
  }
}</code></p>
<p>foldRight &amp; folderLeft
<code>List(a,b,c).foldRight(e)(f) = f(a, f(b, f(c, e)))
List(a,b,c).foldLeft(e)(f)  = f(f(f(e, a), b), c)</code></p>
<p>Retrying to send using foldLeft
<code>def retry(noTimes: Int)(block: =&gt;Future[T]): Future[T] = {
  val ns = (1 to noTimes).toList
  val attempts = ns.map(_ =&gt; ()=&gt;block)
  val failed = Future.failed(new Exception(“boom”))
  val result = attempts.foldLeft(failed)
  ((a,block) =&gt; a recoverWith { block() })
  result
}</code></p>
<p>Retrying to send using foldRight
<code>def retry(noTimes: Int)(block: =&gt;Future[T])= {
  val ns = (1 to noTimes).toList
  val attempts: = ns.map(_ =&gt; () =&gt; block)
  val failed = Future.failed(new Exception)
  val result = attempts.foldRight(() =&gt;failed)
  ((block, a) =&gt; () =&gt; { block() fallbackTo { a() } })
  result ()
}</code></p>
<h3>Async Await</h3>
<p><code>import scala.async.Async._
def async[T](body: =&gt;T) (implicit context: ExecutionContext): Future[T]
def await[T](future: Future[T]): T</code></p>
<p>Reimplementing filter using await
<code>def filter(p: T =&gt; Boolean): Future[T] = async {
  val x = await { this }
  if (!p(x)) {
    throw new NoSuchElementException()
  } else {
    x
  }
}</code></p>
<p>Reimplementing filter without await
<code>def filter(pred: T =&gt; Boolean): Future[T] = {
  val p = Promise[T]()
  this onComplete {
    case Failure(e) =&gt; p.failure(e)
    case Success(x) =&gt;
      if (!pred(x)) p.failure(new NoSuchElementException)
      else p.success(x)
  }
  p.future
}</code></p>
<h3>Promise, promises</h3>
<p>Promises
```
trait Promise[T] {
  def future: Future[T]
  def complete(result: Try[T]): Unit
  def tryComplete(result: Try[T]): Boolean
}</p>
<p>trait Future[T] {
  def onCompleted(f: Try[T] =&gt; Unit): Unit
}</p>
<p>def success(value: T): Unit = this.complete(Success(value))</p>
<p>def failure(t: Throwable): Unit = this.complete(Failure(t))
```</p>
<p>Reimplementing zip using Promises
<code>def zip[S, R](p: Future[S], f: (T, S) =&gt; R): Future[R] = {
  val p = Promise[R]()
  this onComplete {
    case Failure(e) ⇒ p.failure(e)
    case Success(x) ⇒ that onComplete {
      case Failure(e) ⇒ p.failure(e)
      case Success(y) ⇒ p.success(f(x, y))
    }
  }
  p.future
}</code></p>
<p>Reimplementing zip with await
<code>def zip[S, R](p: Future[S], f: (T, S) =&gt; R): Future[R] = async {
  f(await { this }, await { that })
}</code></p>
<p>Implementing sequence
<code>def sequence[T](fts: List[Future[T]]): Future[List[T]] = {
  fts match {
  case Nil =&gt; Future(Nil)
  case (ft::fts) =&gt; ft.flatMap(t =&gt;
    sequence(fts).flatMap(ts =&gt; Future(t::ts)))
  }
}</code></p>
<p>Implementing sequence with await
<code>def sequence[T](fs: List[Future[T]]): Future[List[T]] = async {
  var _fs = fs
  val r = ListBuffer[T]()
  while (_fs != Nil) {
    r += await { _fs.head }
    _fs = _fs.tail
  }
  r.toList
}</code></p>
<p>Implement sequence with Promise
<code>def sequence[T](fs: List[Future[T]]): Future[List[T]] = {
  val p = Promise[List[T]]()
  ???
  p.future
}</code></p>
<h1>Week 4</h1>
<h3>From Try to Future</h3>
<p>TODO</p>
<h3>From Iterables to Observables</h3>
<p>TODO</p>
<h3>Hello World Observables</h3>
<p>TODO</p>
<h3>RX Operations</h3>
<p>TODO</p>
<h3>Subscriptions</h3>
<p>TODO</p>
<h3>Promises and Subjects</h3>
<p>TODO</p>
<h3>RX potpourri</h3>
<p>TODO</p>
<h3>Observable Contract</h3>
<p>TODO</p>
<h1>Week 5</h1>
<h3>Why Actors?</h3>
<ul>
<li>blocking synchronization introduces dead-locks</li>
<li>blocking is bad for CPU utilization</li>
<li>synchronous communication couples sender and receiver</li>
</ul>
<h3>The Actor Model</h3>
<p>```
type Receive = PartialFunction[Any, Unit]</p>
<p>trait Actor {
  implicit val self: ActorRef
  def sender: ActorRef
  implicit val context: ActorContext</p>
<p>def receive: Receive
}</p>
<p>abstract class ActorRef {
  def !(msg: Any)(implicit sender: ActorRef = Actor.noSender): Unit
  def tell(msg: Any, sender: ActorRef) = this.!(msg)(sender)
}</p>
<p>trait ActorContext {
  def become(behavior: Receive, discardOld: Boolean = true): Unit
  def unbecome(): Unit
  def actorOf(p: Props, name: String): ActorRef
  def stop(a: ActorRef): Unit
}
```</p>
<h3>Message Passing Semantics</h3>
<p>An actor is effectively single-threaded:
- messages are received sequentially
- behavior change is effective before processing the next message
- processing one message is the atomic unit of execution</p>
<h1>Week 6</h1>
</body>
</html>
